opForge 8085 Assembler v1.0
ADDR    BYTES                    LINE  SOURCE
------  -----------------------  ----  ------
----                                1  ; The assembler runs two passes over the source file.  The first pass builds
----                                2  ; the symbol table and the second emits the hex file and list file.
----                                3  ;
----                                4  ; Note that the assembler is case-insensitive for instructions, directives,
----                                5  ; register names, and labels.  The labels "label2" and "LABEL2" are the same,
----                                6  ; and an error would be thrown if both were defined.
----                                7   
----                                8  ; The .org directive sets the current address for assembly.  A file can
----                                9  ; contain more than one .org.  The assembler does not detect overlapping
----                               10  ; .org directives and will silently overwrite output in that case.
----    EQU 2000                   11          .org     RAMST + 02000h
----                               12  
----                               13  
----                               14  ; Column one must contain whitespace or a label or a comment start.
----                               15  ; Labels can be up to 32 characters and must start with an alpha.  
----                               16  ; Numbers and the underscore character are permitted in a label.
----                               17  ; Labels can end with a colon, but the colon is optional.
2000    7B                         18  LABEL1: .byte      123             ; labels can be on the same line as code
----                               19  LABEL2
2001    F1                         20          POP     PSW             ; or the label can be before the code
2002    D5                         21  NOSPACE:push    D               ; a space is not required after a label
----                               22  VeryVeryVeryLongLabel:
2003    4C 61 62 65 6C 73 20 63 61 6E 20 62 65 20 75 70 20 74 6F 20 33 32 20 63 68 61 72 61 63 74 65 72 73 20 26 26 20 6D 75 73 74 20 73 74 61 72 74 20 77 69 74 68 20 61 6E 20 61 6C 70 68 61 2E    23      .byte  "Labels can be up to 32 characters && must start with an alpha."
----                               24  
----                               25  ; Expression operators are symbolic, so names like HIGH, LOW, AND, or OR can be
----                               26  ; used as labels if desired.
----                               27  
----                               28  ; The .const directive is used to define a constant value.  It does not emit
----                               29  ; any code.  The label colon is optional for .const, and the label must be
----                               30  ; followed by whitespace.
----    EQU 0000                   31  RAMST   .const     00000h          
----    EQU C000                   32  ROMST   .const     0c000h         
----                               33  
----                               34  ; Constants can be decimal, binary, hex, or octal.  Binary is indicated with a
----                               35  ; trailing 'b' hex with a trailing 'h', and octal with a trailing 'o' or 'q'
----                               36  ; character.  Decimal constants can have a trailing 'd' character, but it is
----                               37  ; not required.  All constants must start with a numeric character, so hex 
----                               38  ; values starting with A-F must have a leading zero.
----    EQU 0037                   39  num0    .const     55              ; Decimal constant
----                               40  num1    .const     55D             ; Decimal constant with optional suffix
   40 | num1    .const     [31m5[0m5D             ; Decimal constant with optional suffix
ERROR: ope005: invalid number: 55D
----    EQU 00A6                   41  num3    .const     0a6h            ; Hex with leading zero
----    EQU 1AB4                   42  num4    .const     1AB4H           ; Hex without leading zero
----    EQU 0065                   43  num5    .const     01100101b       ; Binary
----    EQU 02EF                   44  num6    .const     1357o           ; Octal with trailing 'o'
----    EQU 0209                   45  num7    .const     1011Q           ; Octal with trailing 'q'
----                               46  
----                               47  ; The .byte directive places one or more bytes of data in the output.
2041    05                         48  d1:     .byte      5               ; single byte
2042    12 34 56 78                49  d2:     .byte      12h,34h,56h,78h ; multiple bytes
2046    05 2A 0B                   50  d3:     .byte      5, 02Ah, 1011B  ; Mixed decimal, hex, and binary
----                               51  
----                               52  ; The .byte directive can also be used with strings.  Each octet in the string
----                               53  ; generates one octet of output.  Strings and numeric constants can be mixed
----                               54  ; in a single directive.
----                               55  str1:   .byte      'T'             ; Single character constant
   55 | str1:   .byte      [31m'[0mT'             ; Single character constant
ERROR: ope006: string expression is not supported by portable expression VM
2049    57 65 6C 63 6F 6D 65       56  str2:   .byte      "Welcome"       ; String constant
2050    72 65 64 67 72 65 65 6E    57  str3:   .byte      "red","green"   ; Multiple strings
2058    03 72 65 64 04 62 6C 75 65    58  str4:   .byte      3,"red",4,"blue"; Mixed strings and numerics
----                               59  
----                               60  ; Note that a single character string can also be used anywhere a numeric
----                               61  ; would be allowed.  It evaluates to the ASCII value of the single character.
2061    0E 41                      62          mvi     c, 65           ; Move the letter 'A' into register C.
2063    0E 41                      63          mvi     c, 041H         ; Move the letter 'A' into register C.
2065    0E                         64          mvi     c, 'A'          ; Move the letter 'A' into register C.
   64 |         mvi     c, [31m'[0mA'          ; Move the letter 'A' into register C.
ERROR: ope006: string expression is not supported by portable expression VM
----                               65  
----                               66  ; A two character string can also be used anywhere a numeric would be allowed.
----                               67  ; It evaluates to the 16-bit value of ASCII value of the two characters, where
----                               68  ; the MSB is the first char and the LSB is the second.
2066    21 42 41                   69          lxi     h,04142H        ; All of these evaluate to 4142H
2069    21                         70          lxi     h,'AB'          ; All of these evaluate to 4142H
   70 |         lxi     h,[31m'[0mAB'          ; All of these evaluate to 4142H
ERROR: ope006: string expression is not supported by portable expression VM
206A    21                         71          lxi     h,"AB"          ; All of these evaluate to 4142H
   71 |         lxi     h,[31m"[0mAB"          ; All of these evaluate to 4142H
ERROR: ope006: string expression is not supported by portable expression VM
206B    21                         72          lxi     h,'A'*256 | 'B' ; All of these evaluate to 4142H
   72 |         lxi     h,'A'*256 [31m|[0m 'B' ; All of these evaluate to 4142H
ERROR: ope006: string expression is not supported by portable expression VM
----                               73  
----                               74  
----                               75  ; Some common C-style string escapes are supported: CR, LF, tab, NULL, and
----                               76  ; hex value.  Hex escapes can use upper or lower case and must be 2 digits.
206C    0D 0A 09 2A 2B 00          77      .byte  "\r\n\t\x2a\x2B\0"
----                               78  
----                               79  ; The backslash can also be used to escape quotes or the backslash character
----                               80  ; itself.  Embedded quotes can also be handled by placing double quotes
----                               81  ; inside single quotes or single quotes inside double quotes.
----                               82      .byte  '\\'                    ; Backslash character.
   82 |     .byte  [31m'[0m\\'                    ; Backslash character.
ERROR: ope006: string expression is not supported by portable expression VM
----                               83      .byte  '\''                    ; Single quote character.
   83 |     .byte  [31m'[0m\''                    ; Single quote character.
ERROR: ope006: string expression is not supported by portable expression VM
----                               84      .byte  "'"                     ; Same string using double quotes.
   84 |     .byte  [31m"[0m'"                     ; Same string using double quotes.
ERROR: ope006: string expression is not supported by portable expression VM
2072    41 20 22 71 75 6F 74 65 64 22 20 73 74 72 69 6E 67    85      .byte  "A \"quoted\" string"   ; Quotes within quotes.
2083    41 20 22 71 75 6F 74 65 64 22 20 73 74 72 69 6E 67    86      .byte  'A "quoted" string'     ; Same string using single quotes.
2094    54 68 69 73 20 69 73 6E 27 74 20 62 61 64    87      .byte  "This isn't bad"        ; Single quote in double quotes.
----                               88      
----                               89  ; The following .byte directives are all equivalent  
----    EQU 000D                   90  CR  .const 13
----                               91  LF  .const '\n'
   91 | LF  .const [31m'[0m\n'
ERROR: ope006: string expression is not supported by portable expression VM
20A2    41 42 43 31 32 33 0D 0A    92      .byte  "ABC123\r\n"
20AA    41 42 43 31 32 33 0D       93      .byte  "ABC123",CR,LF
   93 |     .byte  "ABC123",CR,[31mL[0mF
ERROR: Label not found: LF
20B1    41 42 43 31 32 33 0D 0A    94      .byte  "ABC123",13,10
----                               95      .byte  'A','B','C','1','2','3','\r','\n'
   95 |     .byte  [31m'[0mA','B','C','1','2','3','\r','\n'
ERROR: ope006: string expression is not supported by portable expression VM
20B9    41 42 43 31 32             96      .byte  "ABC",31h,32h,"3",'\r',LF
   96 |     .byte  "ABC",31h,32h,[31m"[0m3",'\r',LF
ERROR: ope006: string expression is not supported by portable expression VM
----                               97  
----                               98  ; The .word directive stores one or more 16 bit values.
20BE    03 02                      99  words1: .word      0203h           ; One word value in hex
20C0    B4 1A                     100  words2: .word      num4            ; One word value in decimal
20C2    55 AA                     101  words3: .word      1010101001010101B ; One word value in binary
20C4    02 00 03 00               102  words4: .word      02h, 03h        ; Two word values
20C8    02 00 03 00 FF 04         103  words5: .word      02h, 03, 04ffh  ; Three word values
----                              104  
----                              105  ; Note that .word stores the two octet values in intel (little endian) order, so
----                              106  ; the following two declarations are equivalent:
20CE    34 12                     107          .word      01234h
20D0    34 12                     108          .byte      034h, 012h
----                              109  
----                              110  ; The .ds directive reserves space, but does not generate any output.  It
----                              111  ; simply advances the target address for the next code or data.
----    EQU 0020                  112  StrSize .const     32
20D2    +0080                     113  buffer: .ds  StrSize * 4     ; Reserve space for 4 strings
----                              114  
----                              115  ; Expressions can be used in place of any numeric constant.
2152    00 0C                     116  t:      .word      1024 * 3
2154    31 82 00                  117          LXI     SP, 32 * 4 + 2
2157    21 5D 20                  118          lxi     h, str4 + 5
215A    11 F2 20                  119          lxi     d, buffer + StrSize
215D    39                        120          .byte      7+7*7+7/(7+7-7)
215E    0E                        121          mvi     c, 'A' | 020H
  121 |         mvi     c, 'A' [31m|[0m 020H
ERROR: ope006: string expression is not supported by portable expression VM
215F    0E                        122          mvi     c, 'a' & 11011111b
  122 |         mvi     c, 'a' [31m&[0m 11011111b
ERROR: ope006: string expression is not supported by portable expression VM
----                              123  
----                              124  ; Operators and precedence (highest to lowest):
----                              125  ;   unary: + - ~ ! < >
----                              126  ;   power: **
----                              127  ;   * / %
----                              128  ;   + -
----                              129  ;   shifts: << >>
----                              130  ;   comparisons: == != <> < <= > >= (also =)
----                              131  ;   bitwise: & ^ |
----                              132  ;   logical: && ^^ ||
----                              133  ;   ternary: ?:
----                              134  PREC:
2160    0F 00                     135          .word      (8+7)           ; Parenthesis have highest precedence
2162    FF FF                     136          .word      -1              ; unary plus/minus
2164    02                        137          .byte      >512            ; high byte
2165    00                        138          .byte      <512            ; low byte
2166    08 00                     139          .word      2 ** 3          ; power
2168    02 00                     140          .word      100 / 10 % 4    ; multiply/divide/mod
216A    09 00                     141          .word      2 + 8 - 1       ; add/subtract
216C    01 00                     142          .word      2 <= 3          ; comparisons
216E    03 00                     143          .word      23H & 0FH       ; bitwise AND
2170    F3 00                     144          .word      23H | 0FH ^ 0FFH; bitwise OR/XOR
2172    01 00                     145          .word      !0              ; logical NOT
2174    00 00                     146          .word      1 && 0          ; logical AND
2176    01 00                     147          .word      1 ^^ 0          ; logical XOR
2178    02 00                     148          .word      1 ? 2 : 3       ; ternary
----                              149  
----                              150  ; Logical operators treat any non-zero value as TRUE and return 1 (true) or 0 (false).
217A    01                        151          .byte      !0              ; TRUE
217B    00                        152          .byte      !1              ; FALSE
217C    01                        153          .byte      2 && 3          ; TRUE
217D    01                        154          .byte      0 || 4          ; TRUE
217E    00                        155          .byte      2 ^^ 3          ; FALSE
----                              156  
----                              157  ; Address
----                              158  ; The $ symbol is used in an expression to represent the current address.
----                              159  ; This is useful for calculating the size of objects
217F    48 65 6C 6C 6F 2C 20 77 6F 72 6C 64   160  hello:  .byte  "Hello, world"
----    EQU 000C                  161  strLen  .const     $ - hello       ; Length of the string
----                              162  
----                              163  jump_tab:                       ; Jump table.  Each entry is 3 octets.
----                              164          .byte      'a'             ; ADD command
  164 |         .byte      [31m'[0ma'             ; ADD command
ERROR: ope006: string expression is not supported by portable expression VM
218B    00 01                     165          .word      0100h           ; Handler address
----                              166          .byte      'e'             ; EXAMINE command
  166 |         .byte      [31m'[0me'             ; EXAMINE command
ERROR: ope006: string expression is not supported by portable expression VM
218D    42 01                     167          .word      0142h
----                              168          .byte      'p'             ; PRINT command
  168 |         .byte      [31m'[0mp'             ; PRINT command
ERROR: ope006: string expression is not supported by portable expression VM
218F    20 02                     169          .word      0220h
----                              170          .byte      's'             ; STEP command
  170 |         .byte      [31m'[0ms'             ; STEP command
ERROR: ope006: string expression is not supported by portable expression VM
2191    34 03                     171          .word      0334h
----                              172          .byte      'x'             ; EXIT command
  172 |         .byte      [31m'[0mx'             ; EXIT command
ERROR: ope006: string expression is not supported by portable expression VM
2193    34 04                     173          .word      0434h
----    EQU 0003                  174  entries .const     ($-jump_tab) / 3 ; Number of entries in the table
----                              175  
----                              176  
----                              177  ; It is legal, though probably not wise, to have a label with the same name
----                              178  ; as a register.  This looks confusing, but it will work.  All of the examples
----                              179  ; below load register pair HL with the address of the word at label "SP".  None
----                              180  ; of these have any relation to the SP register.
----                              181  ; Labels that match registers are not permitted in Intel85, but this change was
----                              182  ; added to support some code that was developed with a different assembler.
2195    00 01                     183  SP:     .word      256             ; define a word at location named SP
2197    21                        184          LXI     H,SP            ; laod address of "SP" word into HL pair
  184 |         LXI     H,[31mS[0mP            ; laod address of "SP" word into HL pair
ERROR: expected 16-bit immediate, got register SP
2198    21 95 21                  185          LXI     H,SP+0
219B    21 95 21                  186          LXI     H,0+SP
----                              187  
----                              188  
----                              189  ; Conditional directives
----    EQU 0001                  190  YES         .const 1
----    EQU FFFF                  191  TRUE        .const 0ffffh
----    EQU 0000                  192  NO          .const 0
----    EQU 0000                  193  FALSE       .const 0
----                              194  
----                              195  ; simple .if/.else conditional
----                              196          .if TRUE                        ; match - all code in this block is included
----    EQU 4000                  197                  .org 4000h               ; all labels, directives, and code included
----    EQU 1234                  198  EX1AVAR         .const 1234h
4000    34 12                     199  EX1ADATA:       .word  EX1AVAR
4002    78                        200  EX1A:           mov a,b
----                              201  
----                              202          .else                           ; skip - no code in this block is included
----                              203                  .org 8000h               ; all labels, directives, and code skipped
----                              204  EX1BVAR         .const 5678h
----                              205  EX1BDATA:       .word  EX1VAR
----                              206  EX1B:           mov a,c
----                              207          .endif                          ; END conditional block
----                              208  
----                              209  
----                              210  ; .if/.elseif/.else
----    EQU 1000                  211                  .org 1000h
----                              212          .if YES == NO                   ; skip FALSE
----                              213                  mov a,b
----                              214          .elseif !TRUE                   ; skip FALSE
----                              215                  mov a,c
----                              216          .elseif !FALSE                  ; match TRUE
1000    7A                        217                  mov a,d
----                              218          .elseif TRUE                    ; skip - already matched a previous block
----                              219                  mov a,e
----                              220          .else                           ; skip - already matched a previous block
----                              221                  mov a,h
----                              222          .endif
----                              223  
----                              224  
----                              225  ; TRUE/FALSE values in conditionals
----                              226  ; Any non-zero value is TRUE, zero is FALSE.
----                              227          .if 0                           ; FALSE
----                              228                  adi 11h
----                              229          .elseif 4                       ; TRUE
1001    C6 22                     230                  adi 22h
----                              231          .elseif 4-4                     ; skipped (previous branch matched)
----                              232                  adi 33h
----                              233          .endif
----                              234  
----                              235  
----                              236  ; nested conditionals
----    EQU F000                  237                  .org 0f000h
----                              238          .if FALSE                       ; level 1 - skip
----                              239            .if 0 != 1                    ; level 2 - skip
----                              240  LABEL1:         ori 03h                 ; label and code skipped
----                              241                  jmp 45
----                              242            .elseif FALSE                 ; level 2 - skip
----                              243  LABEL1:         ori 30h                 ; label and code included
----                              244                  jmp 67
----                              245            .else                         ; level 2 - skip
----                              246                  jmp 12
----                              247            .endif                        ; end level 2
----                              248  
----                              249          .elseif YES                     ; level 1 - match
F000    C3 B3 15                  250                  jmp 5555
----                              251            .if !FALSE                    ; level 2 - match
F003    C3 0A 1A                  252                  jmp 6666
----                              253              .if 0                       ; level 3 - skip
----                              254                  jmp 2222
----                              255              .else                       ; level 3 match
F006    4F                        256                  mov c,a
F007    C3 05 0D                  257                  jmp 3333
----                              258              .endif                      ; end level 3
F00A    3E 11                     259                  mvi a,11h               ; included in level 2 match
F00C    06 22                     260                  mvi b,22h               ; included in level 2 match
----                              261  
----                              262            .else                         ; level 2 - skip
----                              263                  jmp 4444
----                              264            .endif                        ; end level 2
F00E    3E 66                     265                  mvi a,66h               ; included in level 1 match
F010    06 77                     266                  mvi b,77h
----                              267          .else                           ; level 1 - skip
----                              268                  mvi a,66h
----                              269                  mvi b,77h
----                              270                  jmp 12                  ; skipped from level 1 .else
----                              271          .endif                          ; end level 1
----                              272  
----                              273  
----                              274  ; Labels and conditionals
----                              275  ; Any of the conditional directives (.if/.elseif/.else/.endif) can have a label.
----                              276  ; This label will be included in the symbol table as long as the directive is
----                              277  ; processed.  It does not matter if the directive evaluates to TRUE.
----                              278  ; A label will not be included in the symbol table if the directive is nested
----                              279  ; within another .if block that is false because the nested directive is not
----                              280  ; evaluated in that case.
----                              281  IFLAB:  .if TRUE                        ; label included
F012    C3 0A 1A                  282                  jmp 6666
----                              283  ELSELAB:.else                           ; label included
----                              284                  mov c,a
----                              285  NOLAB1:         jmp 3333                ; labels ignored because they are nested in
----                              286  NOLAB2:   .if YES                       ; the .else above that did not match
----                              287  NOLAB3:         jmp 1111
----                              288  NOLAB4:   .endif
----                              289  ENDLAB: .endif                          ; label included

Lines: 289  Errors: 21  Warnings: 0

SYMBOL TABLE

LABEL1          : 2000 (8192)
LABEL2          : 2001 (8193)
NOSPACE         : 2002 (8194)
VeryVeryVeryLongLabel: 2003 (8195)
RAMST           : 0000 (0)
ROMST           : c000 (49152)
num0            : 0037 (55)
num3            : 00a6 (166)
num4            : 1ab4 (6836)
num5            : 0065 (101)
num6            : 02ef (751)
num7            : 0209 (521)
d1              : 2041 (8257)
d2              : 2042 (8258)
d3              : 2046 (8262)
str1            : 2049 (8265)
str2            : 2049 (8265)
str3            : 2050 (8272)
str4            : 2058 (8280)
CR              : 000d (13)
words1          : 20be (8382)
words2          : 20c0 (8384)
words3          : 20c2 (8386)
words4          : 20c4 (8388)
words5          : 20c8 (8392)
StrSize         : 0020 (32)
buffer          : 20d2 (8402)
t               : 2152 (8530)
PREC            : 2160 (8544)
hello           : 217f (8575)
strLen          : 000c (12)
jump_tab        : 218b (8587)
entries         : 0003 (3)
SP              : 2195 (8597)
YES             : 0001 (1)
TRUE            : ffff (65535)
NO              : 0000 (0)
FALSE           : 0000 (0)
EX1AVAR         : 1234 (4660)
EX1ADATA        : 4000 (16384)
EX1A            : 4002 (16386)

Total memory is 313 bytes

GENERATED OUTPUT

ADDR    BYTES
------  -----------------------
1000    7A C6 22
2000    7B F1 D5 4C 61 62 65 6C 73 20 63 61 6E 20 62 65
2010    20 75 70 20 74 6F 20 33 32 20 63 68 61 72 61 63
2020    74 65 72 73 20 26 26 20 6D 75 73 74 20 73 74 61
2030    72 74 20 77 69 74 68 20 61 6E 20 61 6C 70 68 61
2040    2E 05 12 34 56 78 05 2A 0B 57 65 6C 63 6F 6D 65
2050    72 65 64 67 72 65 65 6E 03 72 65 64 04 62 6C 75
2060    65 0E 41 0E 41 0E 21 42 41 21 21 21 0D 0A 09 2A
2070    2B 00 41 20 22 71 75 6F 74 65 64 22 20 73 74 72
2080    69 6E 67 41 20 22 71 75 6F 74 65 64 22 20 73 74
2090    72 69 6E 67 54 68 69 73 20 69 73 6E 27 74 20 62
20A0    61 64 41 42 43 31 32 33 0D 0A 41 42 43 31 32 33
20B0    0D 41 42 43 31 32 33 0D 0A 41 42 43 31 32 03 02
20C0    B4 1A 55 AA 02 00 03 00 02 00 03 00 FF 04 34 12
20D0    34 12
2152    00 0C 31 82 00 21 5D 20 11 F2 20 39 0E 0E 0F 00
2162    FF FF 02 00 08 00 02 00 09 00 01 00 03 00 F3 00
2172    01 00 00 00 01 00 02 00 01 00 01 01 00 48 65 6C
2182    6C 6F 2C 20 77 6F 72 6C 64 00 01 42 01 20 02 34
2192    03 34 04 00 01 21 21 95 21 21 95 21
4000    34 12 78
F000    C3 B3 15 C3 0A 1A 4F C3 05 0D 3E 11 06 22 3E 66
F010    06 77 C3 0A 1A
